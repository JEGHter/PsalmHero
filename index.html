<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vokal‑Intonations‑Trainer</title>
  <style>
    :root {
      --bg: #0f1221;
      --card: #171a2d;
      --text: #e9ecff;
      --muted: #99a1c7;
      --accent: #7aa2ff;
      --good: #3ee079;
      --warn: #ffcc66;
      --bad: #ff6b6b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 50% -200px, #1b2050, var(--bg));
      color: var(--text);
      min-height: 100vh; display: grid; place-items: center; padding: 24px;
    }
    .app { width: 100%; max-width: 820px; background: var(--card); border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.35); overflow: hidden; }
    header { padding: 18px 22px; border-bottom: 1px solid #202545; display: flex; align-items: center; gap: 12px; justify-content: space-between; }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.2px; font-weight: 700; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button {
      appearance: none; border: 0; border-radius: 12px; padding: 10px 14px; font-weight: 700; cursor: pointer;
      background: #24305a; color: var(--text); transition: transform .05s ease, filter .2s ease, background .2s ease;
    }
    button:hover { filter: brightness(1.08); }
    button:active { transform: translateY(1px); }
    button.primary { background: linear-gradient(135deg, #4b6bff, #7aa2ff); color: white; }
    button.danger { background: linear-gradient(135deg, #f06666, #ff6b6b); color: white; }

    main { padding: 22px; display: grid; gap: 18px; }

    .readout { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
    .card { background: #111528; border: 1px solid #202545; border-radius: 12px; padding: 14px; }
    .label { font-size: 12px; color: var(--muted); letter-spacing: .4px; text-transform: uppercase; }
    .value { font-size: 28px; font-weight: 800; margin-top: 4px; }
    .sub { font-size: 13px; color: var(--muted); margin-top: 4px; }

    /* Highway */
    .highway-wrap { background: #0d1124; border: 1px solid #1a1f3e; border-radius: 16px; padding: 16px; }
    .highway-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .status-dot { width: 10px; height: 10px; border-radius: 999px; background: var(--bad); box-shadow: 0 0 0 3px rgba(255,107,107,.2); transition: background .2s ease, box-shadow .2s ease; }
    .status-dot.ready { background: var(--warn); box-shadow: 0 0 0 3px rgba(255,204,102,.2); }
    .status-dot.live { background: var(--good); box-shadow: 0 0 0 3px rgba(62,224,121,.2); }

    .highway { position: relative; height: 46px; background:
      linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
      border: 1px solid #222851; border-radius: 12px; overflow: hidden;
    }
    .lane-grid { position:absolute; inset:0; background-image: repeating-linear-gradient(90deg, rgba(255,255,255,.06) 0, rgba(255,255,255,.06) 1px, transparent 1px, transparent 48px); pointer-events:none; }
    .target-bar { position: absolute; top: 4px; bottom: 4px; width: 0; border-radius: 8px; background: linear-gradient(90deg, #4068ff, #7aa2ff); box-shadow: 0 0 18px rgba(122,162,255,.35); transition: width .1s linear; }
    .target-bar.hidden { display:none; }
    .fill { position: absolute; top: 4px; bottom: 4px; left: 0; width: 0%; border-radius: 8px; background: linear-gradient(90deg, #29d67a, #6ef0a4); box-shadow: inset 0 0 10px rgba(0,0,0,.3), 0 0 18px rgba(46, 240, 149, .35); transition: width .08s linear; }
    .pitch-delta { position:absolute; right: 10px; top: 10px; font-size: 12px; color: var(--muted); }

    .legend { display: flex; gap: 16px; align-items: center; color: var(--muted); font-size: 13px; }
    .dot { width: 10px; height: 10px; border-radius: 999px; display:inline-block; margin-right: 6px; }

    footer { padding: 0 22px 22px; color: var(--muted); font-size: 12px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    @media (max-width: 720px) { .readout { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Vokal‑Intonations‑Trainer <span style="opacity:.6;font-weight:600">(Guitar‑Hero‑Modus)</span></h1>
      <div class="controls">
        <button class="primary" id="startBtn">Start</button>
        <button class="danger" id="stopBtn" disabled>Stopp</button>
      </div>
    </header>

    <main>
      <section class="readout">
        <div class="card">
          <div class="label">Zielton</div>
          <div class="value" id="targetNote">–</div>
          <div class="sub" id="targetFreq">– Hz</div>
        </div>
        <div class="card">
          <div class="label">Erkannte Tonhöhe</div>
          <div class="value" id="livePitch">–</div>
          <div class="sub" id="liveCents">–</div>
        </div>
        <div class="card">
          <div class="label">Trefferquote (letzte Runde)</div>
          <div class="value" id="roundScore">–</div>
          <div class="sub">Zeit innerhalb ±30 Cent</div>
        </div>
      </section>

      <section class="highway-wrap">
        <div class="highway-header">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="status-dot" id="statusDot"></span>
            <div class="legend">
              <span><span class="dot" style="background:var(--warn)"></span>Ton wird gespielt (1s)</span>
              <span><span class="dot" style="background:var(--good)"></span>Sing‑Phase (3s)</span>
            </div>
          </div>
          <div class="pitch-delta" id="deltaText">Δ: –</div>
        </div>
        <div class="highway" id="highway">
          <div class="lane-grid"></div>
          <div class="target-bar hidden" id="targetBar"></div>
          <div class="fill" id="fill"></div>
        </div>
      </section>
    </main>

    <footer>
      <p><strong>So funktioniert's:</strong> Nach <em>Start</em> erscheint alle 5 Sekunden ein zufälliger Zielton zwischen <em>C4 (eingestrichenes c)</em> und <em>D5 (zweigestrichenes d)</em>. Der Ton klingt 1 Sekunde. Danach hast du 3 Sekunden, um den Ton zu singen. Wenn du innerhalb ±30 Cent triffst, füllt sich der grüne Balken.</p>
    </footer>
  </div>

<script>
/*** Ton‑ und Noten‑Utilities ***/
const A4 = 440;
const A4_MIDI = 69;
const midiToFreq = m => A4 * Math.pow(2, (m - A4_MIDI) / 12);
const freqToMidi = f => 12 * (Math.log2(f / A4)) + A4_MIDI;
const centsOff = (detected, target) => 1200 * Math.log2(detected / target);

const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const midiToName = m => {
  const name = NOTE_NAMES[Math.round(m) % 12];
  const octave = Math.floor(Math.round(m) / 12) - 1; // MIDI octave mapping
  return `${name}${octave}`;
};

// Bereich: C4 (60) .. D5 (74)
const MIN_MIDI = 60; // C4 (eingestrichenes c)
const MAX_MIDI = 74; // D5 (zweigestrichenes d)

/*** DOM‑Refs ***/
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const targetNoteEl = document.getElementById('targetNote');
const targetFreqEl = document.getElementById('targetFreq');
const livePitchEl = document.getElementById('livePitch');
const liveCentsEl = document.getElementById('liveCents');
const roundScoreEl = document.getElementById('roundScore');
const statusDot = document.getElementById('statusDot');
const targetBar = document.getElementById('targetBar');
const fillEl = document.getElementById('fill');
const deltaText = document.getElementById('deltaText');
const highway = document.getElementById('highway');

/*** Audio‑Setup ***/
let audioCtx, analyser, micSource, micStream, osc, gain;
let rafId, detectActive = false;

async function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // Mikrofon
  micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false });
  micSource = audioCtx.createMediaStreamSource(micStream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  micSource.connect(analyser);
  // Synth für Zielton
  osc = audioCtx.createOscillator();
  osc.type = 'sine';
  gain = audioCtx.createGain();
  gain.gain.value = 0; // stumm, bis gespielt wird
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
}

/*** Pitch Detection (Auto‑Korrelation) ***/
const bufLen = 2048; 
const buf = new Float32Array(bufLen);
function autoCorrelate() {
  analyser.getFloatTimeDomainData(buf);
  // Energie prüfen
  let rms = 0;
  for (let i=0;i<bufLen;i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms / bufLen);
  if (rms < 0.01) return -1; // zu leise

  let r1 = 0, r2 = bufLen-1, thres = 0.2;
  for (let i=0;i<bufLen/2;i++) if (Math.abs(buf[i])<thres) { r1 = i; break; }
  for (let i=1;i<bufLen/2;i++) if (Math.abs(buf[bufLen-i])<thres) { r2 = bufLen-i; break; }
  const trimmed = buf.slice(r1, r2);

  const size = trimmed.length;
  const c = new Array(size).fill(0);
  for (let i=0; i<size; i++) {
    for (let j=0; j<size-i; j++) c[i] = c[i] + trimmed[j]*trimmed[j+i];
  }
  let d=0; while (c[d]>c[d+1]) d++;
  let maxval=-1, maxpos=-1;
  for (let i=d; i<size; i++) if (c[i]>maxval) { maxval=c[i]; maxpos=i; }
  let T0 = maxpos;
  // Parabolische Interpolation zur Feinabstimmung
  const x1 = c[T0-1] || 0, x2 = c[T0] || 0, x3 = c[T0+1] || 0;
  const a = (x1 + x3 - 2*x2) / 2;
  const b = (x3 - x1) / 2;
  if (a) T0 = T0 - b/(2*a);
  const freq = audioCtx.sampleRate / T0;
  if (freq < 50 || freq > 2000 || !isFinite(freq)) return -1;
  return freq;
}

/*** Spiel‑Logik ***/
let roundTimer = null; // 5s‑Intervall
let state = 'idle'; // 'idle' | 'play' | 'sing'
let currentMidi = null; let currentFreq = null; let currentName = null;
let singStartTs = 0; let onTargetMs = 0; let singPhase = false;
const TOLERANCE_CENTS = 30; // ±30 Cent

function pickRandomMidi() {
  const m = Math.floor(Math.random() * (MAX_MIDI - MIN_MIDI + 1)) + MIN_MIDI;
  return m;
}

function updateReadoutPitch(detFreq) {
  if (detFreq === -1) {
    livePitchEl.textContent = '–';
    liveCentsEl.textContent = '–';
    deltaText.textContent = 'Δ: –';
    return;
  }
  const midi = freqToMidi(detFreq);
  const name = midiToName(midi);
  const cents = centsOff(detFreq, currentFreq||detFreq);
  livePitchEl.textContent = `${name}`;
  liveCentsEl.textContent = `${detFreq.toFixed(1)} Hz`;
  deltaText.textContent = `Δ: ${isFinite(cents)?cents.toFixed(0):'–'} cent`;
}

function setStatus(mode) {
  statusDot.classList.remove('ready','live');
  if (mode==='play') statusDot.classList.add('ready');
  if (mode==='sing') statusDot.classList.add('live');
}

function showTargetBar(show) {
  targetBar.classList.toggle('hidden', !show);
  if (show) {
    // Die Ziel‑Bar wächst über 3s von 0% auf 100% (Visuelle Anmutung)
    targetBar.style.width = '0%';
    targetBar.animate([{width:'0%'},{width:'100%'}], { duration: 3000, fill: 'forwards', easing: 'linear' }).onfinish = e=>{
      targetBar.style.width = '100%';
    };
  }
}

function resetFill() { fillEl.style.width = '0%'; }
function setFillByMs(ms) { const pct = Math.max(0, Math.min(100, (ms/3000)*100)); fillEl.style.width = pct + '%'; }

function playTarget(freq) {
  gain.gain.cancelScheduledValues(audioCtx.currentTime);
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 0.02);
  gain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 0.98);
  gain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + 1.00);
}

function startRound() {
  // 1) Neuen zufälligen Ton wählen
  currentMidi = pickRandomMidi();
  currentFreq = midiToFreq(currentMidi);
  currentName = midiToName(currentMidi);
  targetNoteEl.textContent = currentName;
  targetFreqEl.textContent = `${currentFreq.toFixed(2)} Hz`;

  // 2) 1s abspielen
  state = 'play'; setStatus('play'); showTargetBar(false); resetFill();
  playTarget(currentFreq);

  // 3) Nach 1s in Sing‑Phase wechseln (3s)
  window.setTimeout(()=>{
    state = 'sing'; setStatus('sing'); showTargetBar(true);
    singPhase = true; onTargetMs = 0; singStartTs = performance.now();

    // Nach 3s Sing‑Phase beenden, Score anzeigen
    window.setTimeout(()=>{
      singPhase = false; state = 'idle'; setStatus('idle'); showTargetBar(false);
      const pct = Math.round((onTargetMs/3000)*100);
      roundScoreEl.textContent = `${pct}%`;
      // 1s Leerlauf bis zur nächsten Runde (gemeinsam mit dem 5s‑Takt)
    }, 3000);
  }, 1000);
}

function loop() {
  const f = autoCorrelate();
  updateReadoutPitch(f);
  if (singPhase && f !== -1 && currentFreq) {
    const cents = Math.abs(centsOff(f, currentFreq));
    if (cents <= TOLERANCE_CENTS) {
      // Zeit innerhalb der Toleranz akkumulieren
      const now = performance.now();
      const elapsed = now - (singStartTs + onTargetMs);
      onTargetMs = Math.min(3000, onTargetMs + Math.min(16, elapsed)); // begrenzen
      setFillByMs(onTargetMs);
    }
  }
  rafId = requestAnimationFrame(loop);
}

/*** Start/Stop ***/
async function start() {
  startBtn.disabled = true; stopBtn.disabled = false;
  if (!audioCtx) {
    try { await initAudio(); } catch (e) {
      alert('Zugriff aufs Mikrofon fehlgeschlagen. Bitte Berechtigung erlauben.');
      startBtn.disabled = false; stopBtn.disabled = true; return;
    }
  }
  if (audioCtx.state === 'suspended') await audioCtx.resume();
  detectActive = true; loop();
  // Sofort erste Runde, danach alle 5s
  startRound();
  roundTimer = window.setInterval(startRound, 5000);
}

function stop() {
  startBtn.disabled = false; stopBtn.disabled = true;
  detectActive = false; cancelAnimationFrame(rafId);
  if (roundTimer) { clearInterval(roundTimer); roundTimer = null; }
  state = 'idle'; setStatus('idle'); showTargetBar(false); resetFill();
  livePitchEl.textContent = '–'; liveCentsEl.textContent = '–'; deltaText.textContent = 'Δ: –';
  roundScoreEl.textContent = '–'; targetNoteEl.textContent = '–'; targetFreqEl.textContent = '– Hz';
  if (gain) gain.gain.setValueAtTime(0, audioCtx.currentTime);
}

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', stop);

// Aufräumen bei Navigationswechsel
window.addEventListener('visibilitychange', ()=>{
  if (document.hidden && audioCtx) gain && (gain.gain.value = 0);
});

</script>
</body>
</html>
